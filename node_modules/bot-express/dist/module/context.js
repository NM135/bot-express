"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto = require("crypto");
const clone = require("rfdc/default");
module.exports = class Context {
    /**
     * @constructor
     * @param {*} [options]
     */
    constructor(options = {}) {
        const o = options;
        this.session_id = o.session_id || crypto.randomBytes(80).toString('hex');
        this.chat_id = o.chat_id || crypto.randomBytes(20).toString('hex');
        this.launched_at = o.launched_at || new Date().getTime();
        this.event = o.event;
        this.intent = o.intent;
        this.global = o.global || {
            confirming: {}
        };
        this.confirmed = o.confirmed || {};
        this.confirming = null;
        this.to_confirm = [];
        this.heard = o.heard || {};
        this.sender_language = o.sender_language || null;
        this.translation = null;
        this.param_change_history = [];
        this.previous = {
            event: null,
            intent: [],
            confirmed: [],
            processed: [],
            message: []
        };
        this.archive = []; // To save history of previous context.
        this.rewind = [];
        this._flow = o.flow;
        this._message_queue = [];
        this._pause = false;
        this._exit = false;
        this._init = false;
        this._switch_intent = o._switch_intent || null;
        this._parent = o._parent || [];
        this._parent_parameter = o._parent_parameter || {};
        this._sub_skill = o._sub_skill || false;
        this._sub_parameter = o._sub_parameter || false;
    }
    static get_archive(context) {
        context.archive.unshift({
            chat_id: context.chat_id,
            launched_at: context.launched_at,
            event: context.event,
            intent: context.intent,
            global: context.global,
            confirmed: context.confirmed,
            confirming: context.confirming,
            to_confirm: context.to_confirm,
            heard: context.heard,
            sender_language: context.sender_language,
            translation: context.translation
        });
        return clone(context.archive);
    }
    static remove_buffer(obj) {
        return JSON.parse(JSON.stringify(obj), (key, value) => {
            if (typeof value === "object" && value && value.type && value.type == "Buffer") {
                return undefined;
            }
            else {
                return value;
            }
        });
    }
};
//# sourceMappingURL=context.js.map